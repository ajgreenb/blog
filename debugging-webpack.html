<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">

  <title>Debugging a webpack project</title>

  <link href="style.css" rel="stylesheet">
  <link href="post.css" rel="stylesheet">
</head>
<body>

<h1>Debugging a webpack project</h1>

<span class="date">February 26, 2018</span>

<p>
I was working on a project that uses
<a href="https://webpack.js.org/">webpack</a> to bundle assets together and
<a href="https://github.com/jantimon/html-webpack-plugin">HtmlWebpackPlugin</a>
to autogenerate an <code>index.html</code> file. The plugin reads the names of
each bundle emitted by webpack and injects <code>&lt;script&gt;</code> tags into
the index file for them. My setup creates three bundles:
</p>

<ul>
<li><code>vendor.js</code>, which contains third-party libraries,</li>
<li><code>main.js</code>, which contains the project's source code, and</li>
<li><code>manifest.js</code>, which contains the webpack runtime and loads
  the webpack manifest for the project.
</li>
</ul>

<p>
The webpack manifest is a JSON file that contains information about the
different bundles generated by webpack. The runtime uses it to know which files
to load. HtmlWebpackPlugin injects three <code>&lt;script&gt;</code> tags into
<code>index.html</code>&mdash;one for each of the three files listed above.
</p>

<p>
On Mac OS, the project loaded in the browser with no problem&mdash;no errors in
the JavaScript console. After pushing the project to a server running Ubuntu
Linux, building it, and deploying it, the project would not load. The JavaScript
console displayed the following error:
</p>

<div class="code error">
<pre>
Method 'call' does not exist for undefined!
</pre>
</div>
<p>
This is a generic error in JavaScript, so the message alone doesn't give much of
a clue as to its cause. I traced the message back to the line that throws the
error:
</p>

<div class="code">
<pre>
modules[moduleId].call(module.exports, ...);
</pre>
</div>

<p>
This line of code comes from <code>manifest.js</code>, the bundle containing the
webpack runtime. The runtime can be hard to follow, but it appears that this
line attempts to evaluate (execute) a JavaScript module when a dependent module
<code>require</code>s it for the first time. For some reason, on Linux,
<code>modules[moduleId]</code> was <code>undefined</code>, but on Mac OS it was
not.
</p>

<p>
One issue that made debugging harder was that the bundles had been minified
using webpack's
<a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin">
UglifyJsPlugin</a>. It took me too long to discover that the problem occurred
even with minification disabled. If I had spent more time testing different
conditions to see if the error persisted, I might not have burned so much time
trying to get source maps to work effectively.
</p>

<p>
I also spent a lot of time googling variations on "webpack build works on mac
but not on linux", but none of the results seemed to be related to my issue.
</p>

<p>
After rebuilding the project in development mode (which omits UglifyJsPlugin),
I found that the missing <code>moduleId</code> was
<code>&apos;./node_modules/react/react.js&apos;</code>. Inspecting the
<code>modules</code> object, the only <code>moduleId</code>s present
corresponded to project source files. Vendor modules, like React, were not
present. At this point, astute readers might discern the cause of the problem,
but I was still grasping at straws.
</p>

<p>
As a next step, I copied all the built files from the Linux server to my Mac
laptop to compare them with the locally built files (the working ones.) I used
the <code>comm</code> command, which compares two files and outputs lines that
differ between the two. Since the line that threw the error came from
<code>manifest.js</code>, I tried
</p>

<div class="code">
<pre>
$ comm -3 manifest.js server/manifest.js
</pre>
</div>

<p>
The <code>-3</code> argument suppresses printing of identical lines from the
two files. The output was empty, signifying that the two files were identical.
So I tried running <code>comm</code> over each of the pairs of built JavaScript
files. All were identical! At this point I was severely head-scratching.
Flailing, and not a little bit frustrated, I tried running <code>comm</code> on
the two <code>index.html</code> files. This was the string-tug that caused the
mystery to unwind. Two lines were output, for the lines that differed in each
file. In the Mac-built <code>index.html</code>, the line (split into three for
readability)
</p>

<div class="code">
<pre>
&lt;script type=&quot;text/javascript&quot; src=&quot;manifest.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;vendor.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;
</pre>
</div>

<p>
differed from the line in the Linux-built <code>index.html</code>:
</p>

<div class="code">
<pre>
&lt;script type=&quot;text/javascript&quot; src=&quot;manifest.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;vendor.js&quot;&gt;&lt;/script&gt;
</pre>
</div>

<p>
On Linux, the HtmlWebpackPlugin was swapping the order of the injected
<code>&lt;script&gt;</code> tags, causing <code>main.js</code> to be loaded
before <code>vendor.js</code>. Because <code>main.js</code> (which contains the
project source code) tries to import third-party libraries (React, in this
case), when it was evaluated before <code>vendor.js</code> was evaluated, the
<code>moduleId</code> for React didn't yet exist in the <code>modules</code>
object&mdash;and <code>modules[moduleId]</code> evaluated to
<code>undefined</code>. In other words, the React module hadn't yet been
loaded!
</p>

<p>
Once I understood the problem, I consulted the documentation for
HtmlWebpackPlugin and found a configuration option that solved it. By setting
<code>chunksSortMode</code> to <code>&apos;dependency&apos;</code>, the plugin
would ensure that the <code>&lt;script&gt;</code> tags would be injected in the
correct order.
</p>

<div class="code">
<pre>
new HtmlWebpackPlugin({
  chunksSortMode: &apos;dependency&apos;,
})
</pre>
</div>

<p>
The default value for this option is <code>&apos;auto&apos;</code>, which I
guess injects the tags in the order they're read in from the file system? It
must be that a difference between Linux and Mac OS causes the file names to be
read in different orders.
</p>

</body>
</html>
